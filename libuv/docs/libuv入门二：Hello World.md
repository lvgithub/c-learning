libuv入门二：Hello World

## 介绍

libuv强制执行异步、事件驱动的编程风格来编写程序，它的核心工作是提供一个`事件循环`和`基于回调`的I/O和其他活动通知。libuv提供了诸如计时器、非阻塞网络支持、异步文件系统访问、子进程等核心。

系统程序最常见的活动是处理输入和输出，而不是大量的计算。使用传统的输入/输出函数（read、fprintf等）的问题是它们阻塞了。与处理器的速度相比，实际写入硬盘或从网络读取数据所需的时间过长。函数在任务完成前不会返回，此时整个程序什么也不做，但是把资源占用着。对于高性能程序来说，这是核心瓶颈，因为其他活动和IO操作也会被阻塞。

标准的解决方案之一是使用线程，每个阻塞的IO操作都是一个线程，当阻塞函数被调用的时候，处理器可以安排其他的线程运行。

libuv采用的方法使用另一种样式，即异步、非阻塞风格。大多数现代操作系统都提供事件通知子系统。例如，在一个socket上正常的read调用将阻塞，直到发送方实际发送了一些内容。相反，应用程序可以请求操作系统监视套接字并将事件通知放入队列中。应用程序可以在方便的时候检查事件并获取数据。它是异步的，因为应用程序在一个点表示兴趣，然后在另一个点（在时间和空间上）使用数据。它是异步的，因为程序在它是先对某个事件进行订阅，然后在另外一个时间或者空间，数据准备好的时候才去使用数据。这是非阻塞的，因为应用程序可以自由的去执行其他任务。这是非常匹配libuv事件循环，因为操作系统可以被视为另外一个libuv事件循环。非阻塞事件确保其他事件能被足够快的处理。



## 第一个程序



```c
#include <stdio.h>
#include <stdlib.h>
#include <uv.h>

int main()
{
    uv_loop_t *loop = malloc(sizeof(uv_loop_t));
    uv_loop_init(loop);
    
    printf("Now quitting.\n");
    uv_run(loop, UV_RUN_DEFAULT);

    uv_loop_close(loop);
    free(loop);
    return 0;
}
```

这个程序会立即退出，因为他没有要处理的事件，必须告诉libuv的事件循环去监控各种API函数事件。

程序逻辑：

1. 申明一个事件循环 ` uv_loop_t `，它管理了同一个事件循环的所有资源，并且在整个事件循环的生命周期内都是可用的
2. `uv_loop_init`： 对事件循环进行初始化
3. `uv_run`：启动事件循环
4. `uv_loop_close`：释放loop所有内部资源，仅当loop执行完毕且所有打开的句柄和请求都已关闭时，才调用此函数。否则会返回`UV_EBUSY.`
5. `free`：释放内存



































